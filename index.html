<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>玖数天籁</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            margin: 0;
            background-color: #f5f5f5;
            color: #333;
            display: flex;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 600px;
        }

        h1 {
            text-align: center;
            color: #444;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 10px;
        }

        button {
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background-color: #218838;
        }

        #volumeValue {
            display: inline-block;
            margin-left: 10px;
            font-weight: normal;
        }

        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
            width: 100%;
            height: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>玖数天籁</h1>
        
        <label for="frequencyInput">频率 (Hz): </label>
        <input type="number" id="frequencyInput" value="40" min="20" max="1000" step="1" onchange="updateFrequency(this.value)">
        
        <label for="waveformSelect">波形: </label>
        <select id="waveformSelect" onchange="updateWaveform(this.value)">
            <option value="sine">Sine</option>
            <option value="triangle">Triangle</option>
            <option value="square">Square</option>
            <option value="sawtooth">Sawtooth</option>
            <option value="pulse">Pulse</option>
            <option value="noise">Noise</option>
            <option value="ramp">Ramp</option>
        </select>
        
        <label for="volumeSlider">音量: <span id="volumeValue">0.5</span></label>
        <input type="range" id="volumeSlider" min="0" max="1" value="0.5" step="0.01" onchange="updateVolume(this.value)">
        <canvas id="oscilloscope"></canvas>
        
        <label for="durationInput">音长 (秒): </label>
        <input type="number" id="durationInput" value="300" min="1" max="6000" step="1">
        
        <button onclick="startAudio()">播放</button>
        <button onclick="startAudioIndefinitely()">连续播放</button>
        <button onclick="stopAudio()">停止</button>
    </div>

    <script>
        let audioContext;
        let oscillator;
        let gainNode;
        let analyser;
        let durationTimeout;
        let canvas, canvasContext;
        let animationId;

        window.onload = function() {
            canvas = document.getElementById('oscilloscope');
            canvasContext = canvas.getContext('2d');
            startAudioIndefinitely();  // 页面加载时自动播放
        };

        function startAudio() {
            stopAudio(); // Stop any existing audio
            clearTimeout(durationTimeout);

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            const waveform = document.getElementById('waveformSelect').value;

            let gainCoefficient = 1;
            switch(waveform) {
                case 'sine':
                    gainCoefficient = 5.0; // 正弦波的系数
                    break;
                case 'square':
                    gainCoefficient = 0.5; // 方波的系数
                    break;
                case 'sawtooth':
                    gainCoefficient = 0.5; // 锯齿波的系数
                    break;
                case 'triangle':
                    gainCoefficient = 0.7; // 三角波的系数
                    break;
                case 'pulse':
                    gainCoefficient = 0.3; // 脉冲波的系数
                    break;
                case 'ramp':
                    gainCoefficient = 0.4; // 斜波的系数
                    break;
                case 'noise':
                    gainCoefficient = 0.2; // 噪声波的系数
                    break;
            }

            if (waveform === 'noise') {
                generateNoise(gainCoefficient);
            } else {
                oscillator = audioContext.createOscillator();
                oscillator.type = waveform === 'pulse' ? 'square' : waveform;
                oscillator.frequency.setValueAtTime(parseFloat(document.getElementById('frequencyInput').value), audioContext.currentTime);

                gainNode = audioContext.createGain();
                const adjustedGain = gainCoefficient * parseFloat(document.getElementById('volumeSlider').value);
                gainNode.gain.setValueAtTime(adjustedGain, audioContext.currentTime);

                if (waveform === 'pulse') {
                    const pulseWidth = 0.5; // This can be adjusted or made dynamic
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(adjustedGain * pulseWidth, audioContext.currentTime);
                } else if (waveform === 'ramp') {
                    oscillator.frequency.linearRampToValueAtTime(parseFloat(document.getElementById('frequencyInput').value) * 2, audioContext.currentTime + 0.1);
                }

                oscillator.connect(gainNode);
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);

                oscillator.start();
            }

            const duration = parseFloat(document.getElementById('durationInput').value);
            durationTimeout = setTimeout(() => stopAudio(), duration * 1000);

            drawOscilloscope();
        }

        function generateNoise(gainCoefficient) {
            const bufferSize = 2 * audioContext.sampleRate;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const whiteNoise = audioContext.createBufferSource();
            whiteNoise.buffer = noiseBuffer;
            whiteNoise.loop = true;

            gainNode = audioContext.createGain();
            const adjustedGain = gainCoefficient * parseFloat(document.getElementById('volumeSlider').value);
            gainNode.gain.setValueAtTime(adjustedGain, audioContext.currentTime);

            whiteNoise.connect(gainNode);
            gainNode.connect(analyser);
            analyser.connect(audioContext.destination);

            whiteNoise.start();
            oscillator = whiteNoise; // So that stopAudio can stop it
        }

        function startAudioIndefinitely() {
            stopAudio(); // Stop any existing audio
            clearTimeout(durationTimeout);

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            const waveform = document.getElementById('waveformSelect').value;

            let gainCoefficient = 1;
            switch(waveform) {
                case 'sine':
                    gainCoefficient = 5.0;
                    break;
                case 'square':
                    gainCoefficient = 0.5;
                    break;
                case 'sawtooth':
                    gainCoefficient = 0.5;
                    break;
                case 'triangle':
                    gainCoefficient = 0.7;
                    break;
                case 'pulse':
                    gainCoefficient = 0.3;
                    break;
                case 'ramp':
                    gainCoefficient = 0.4;
                    break;
                case 'noise':
                    gainCoefficient = 0.2;
                    break;
            }

            if (waveform === 'noise') {
                generateNoise(gainCoefficient);
            } else {
                oscillator = audioContext.createOscillator();
                oscillator.type = waveform === 'pulse' ? 'square' : waveform;
                oscillator.frequency.setValueAtTime(parseFloat(document.getElementById('frequencyInput').value), audioContext.currentTime);

                gainNode = audioContext.createGain();
                const adjustedGain = gainCoefficient * parseFloat(document.getElementById('volumeSlider').value);
                gainNode.gain.setValueAtTime(adjustedGain, audioContext.currentTime);

                if (waveform === 'pulse') {
                    const pulseWidth = 0.5;
                    gainNode.gain.setValueAtTime(adjustedGain * pulseWidth, audioContext.currentTime);
                } else if (waveform === 'ramp') {
                    oscillator.frequency.linearRampToValueAtTime(parseFloat(document.getElementById('frequencyInput').value) * 2, audioContext.currentTime + 0.1);
                }

                oscillator.connect(gainNode);
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);

                oscillator.start();
            }

            drawOscilloscope();
        }

        function stopAudio() {
            if (oscillator) {
                oscillator.stop();
                oscillator.disconnect();
            }
            if (audioContext) {
                audioContext.close();
            }
            clearTimeout(durationTimeout);
            cancelAnimationFrame(animationId);
            clearCanvas();
        }

        function updateFrequency(value) {
            if (oscillator && oscillator.frequency) {
                oscillator.frequency.setValueAtTime(value, audioContext.currentTime);
            }
        }

        function updateVolume(value) {
            if (gainNode) {
                const waveform = document.getElementById('waveformSelect').value;
                
                let gainCoefficient = 1;
                switch(waveform) {
                    case 'sine':
                        gainCoefficient = 5.0;
                        break;
                    case 'square':
                        gainCoefficient = 0.5;
                        break;
                    case 'sawtooth':
                        gainCoefficient = 0.5;
                        break;
                    case 'triangle':
                        gainCoefficient = 0.7;
                        break;
                    case 'pulse':
                        gainCoefficient = 0.3;
                        break;
                    case 'ramp':
                        gainCoefficient = 0.4;
                        break;
                    case 'noise':
                        gainCoefficient = 0.2;
                        break;
                }

                const adjustedGain = gainCoefficient * parseFloat(value);
                gainNode.gain.setValueAtTime(adjustedGain, audioContext.currentTime);
            }

            document.getElementById("volumeValue").innerText = value;
        }

        function updateWaveform(value) {
            if (oscillator) {
                oscillator.type = value === 'pulse' ? 'square' : value;

                if (value === 'ramp') {
                    oscillator.frequency.linearRampToValueAtTime(parseFloat(document.getElementById('frequencyInput').value) * 2, audioContext.currentTime + 0.1);
                }
            }

            updateVolume(document.getElementById('volumeSlider').value);
        }

        function drawOscilloscope() {
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                animationId = requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);

                canvasContext.fillStyle = '#f5f5f5';
                canvasContext.fillRect(0, 0, canvas.width, canvas.height);

                canvasContext.lineWidth = 2;
                canvasContext.strokeStyle = '#333';

                canvasContext.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;

                for(let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if(i === 0) {
                        canvasContext.moveTo(x, y);
                    } else {
                        canvasContext.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                canvasContext.lineTo(canvas.width, canvas.height / 2);
                canvasContext.stroke();
            }

            draw();
        }

        function clearCanvas() {
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>
